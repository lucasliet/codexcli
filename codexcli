#!/usr/bin/env bash
# Usage:
#   codexcli [YOUR_INPUT]
# Example:
#   codexcli "olá como vai?"
#   codexcli ola como vai

CODEXCLI_ACCESS_TOKEN=$(jq -r '.tokens.access_token' ~/.codex/auth.json)
CODEXCLI_ACCOUNT_ID=$(jq -r '.tokens.account_id' ~/.codex/auth.json)
CODEXCLI_SESSION_ID="${SESSION_ID:-$(uuidgen | tr '[:upper:]' '[:lower:]')}"
CODEXCLI_MODEL="gpt-5"
CODEXCLI_HISTORY_FILE="/tmp/codexcli_messages"
CODEXCLI_IMAGE_FLAG=0
CODEXCLI_IMAGE_PATH=""
CODEXCLI_TEXT=""

if [ -z "${CODEXCLI_ACCESS_TOKEN:-}" ] || [ "$CODEXCLI_ACCESS_TOKEN" = "null" ]; then
echo "ACCESS_TOKEN não encontrado em ~/.codex/auth.json. Rode 'codex login' antes."; exit 1
fi
if [ -z "${CODEXCLI_ACCOUNT_ID:-}" ] || [ "$CODEXCLI_ACCOUNT_ID" = "null" ]; then
echo "ACCOUNT_ID não encontrado no auth.json. Tente relogar com 'codex login'."; exit 1
fi

for arg in "$@"; do
  if [ "$arg" = "--help" ]; then
    echo "Uso: codexcli [--prompt \"texto\"] [--image [caminho]] [texto...]"
    echo "Exemplos:"
    echo "  codexcli 'olá mundo'"
    echo "  codexcli --image foto.png --prompt 'Explique a imagem'"
    echo "  codexcli --image 'Explique a imagem da última captura de tela'"
    exit 0
  fi
done

CODEXCLI_POS_ARGS=()
while [ $# -gt 0 ]; do
  case "$1" in
    --prompt)
      CODEXCLI_TEXT="$2"; shift 2;;
    --image)
      CODEXCLI_IMAGE_FLAG=1
      if [ -n "${2:-}" ] && [ "${2#--}" != "$2" ] ; then
        shift 1
      elif [ -n "${2:-}" ]; then
        CODEXCLI_IMAGE_PATH="$2"; shift 2
      else
        shift 1
      fi;;
    *)
      CODEXCLI_POS_ARGS+=("$1"); shift 1;;
  esac
done
if [ -z "$CODEXCLI_TEXT" ] && [ ${#CODEXCLI_POS_ARGS[@]} -gt 0 ]; then
  CODEXCLI_TEXT="${CODEXCLI_POS_ARGS[*]}"
fi
if [ "$CODEXCLI_IMAGE_FLAG" -eq 1 ] && [ -z "$CODEXCLI_TEXT" ]; then
  CODEXCLI_TEXT="Explain what is in this image."
fi
if [ -z "$CODEXCLI_TEXT" ]; then
  CODEXCLI_TEXT=""
fi

# Carrega as mesmas instruções usadas pelo Codex CLI a partir do repositório oficial (sempre atualizado)
codexcli_now_ts() { date +%s; }
codexcli_is_stale() { f="$1"; t="${2:-${CODEX_INSTRUCTIONS_TTL:-86400}}"; [ ! -f "$f" ] && return 0; mt=$(stat -f %m "$f" 2>/dev/null || stat -c %Y "$f" 2>/dev/null || echo 0); [ $(( $(codexcli_now_ts) - mt )) -ge "$t" ]; }

CODEXCLI_VENDOR_DIR=""
if [ -d "$HOME/.local/share/codexcli/vendor/openai-codex" ]; then
  CODEXCLI_VENDOR_DIR="$HOME/.local/share/codexcli/vendor/openai-codex"
elif [ -d "vendor/openai-codex" ]; then
  CODEXCLI_VENDOR_DIR="vendor/openai-codex"
elif [ -d "$HOME/Projetos/codex" ]; then
  CODEXCLI_VENDOR_DIR="$HOME/Projetos/codex"
fi

codexcli_maybe_update_submodule() {
  CODEXCLI_STAMP="$HOME/.local/share/codexcli/.submodule.updated"
  if [ -d "$HOME/.local/share/codexcli/vendor/openai-codex/.git" ] && command -v git >/dev/null 2>&1; then
    if codexcli_is_stale "$CODEXCLI_STAMP"; then
      if git -C "$HOME/.local/share/codexcli/vendor/openai-codex" fetch -q origin && git -C "$HOME/.local/share/codexcli/vendor/openai-codex" checkout -q main && git -C "$HOME/.local/share/codexcli/vendor/openai-codex" pull -q --ff-only; then
        date +%s > "$CODEXCLI_STAMP" 2>/dev/null || true
      fi
    fi
  fi
}

codexcli_maybe_update_submodule

if [ -f "$CODEXCLI_VENDOR_DIR/codex-rs/core/prompt.md" ] && [ -f "$CODEXCLI_VENDOR_DIR/codex-rs/apply-patch/apply_patch_tool_instructions.md" ]; then
  CODEXCLI_INSTRUCTIONS="$(cat "$CODEXCLI_VENDOR_DIR/codex-rs/core/prompt.md"; printf '\n'; cat "$CODEXCLI_VENDOR_DIR/codex-rs/apply-patch/apply_patch_tool_instructions.md")"
else
  echo "Falha ao localizar os arquivos no submódulo do Codex. Verifique a instalação." >&2
  exit 1
fi

if [ "$CODEXCLI_IMAGE_FLAG" -eq 1 ]; then
  if [ -z "$CODEXCLI_IMAGE_PATH" ]; then
    CODEXCLI_IMAGE_PATH=$(ls -1t *.png *.jpg *.jpeg *.webp 2>/dev/null | head -n1 || true)
  fi
  if [ -z "$CODEXCLI_IMAGE_PATH" ] || [ ! -f "$CODEXCLI_IMAGE_PATH" ]; then
    echo "Arquivo de imagem não encontrado. Forneça um caminho ou coloque uma imagem no diretório atual." >&2
    exit 1
  fi
  if ! command -v file >/dev/null 2>&1; then
    echo "O comando 'file' é necessário para detectar o mime type." >&2
    exit 1
  fi
  CODEXCLI_MIME=$(file --mime-type -b "$CODEXCLI_IMAGE_PATH")
  CODEXCLI_B64=$(base64 < "$CODEXCLI_IMAGE_PATH" | tr -d '\n')
  CODEXCLI_DATA_URL="data:${CODEXCLI_MIME};base64,${CODEXCLI_B64}"
  CODEXCLI_CONTENT_JSON=$(jq -n --arg text "$CODEXCLI_TEXT" --arg image_url "$CODEXCLI_DATA_URL" '[{type:"input_text", text:$text},{type:"input_image", image_url:$image_url}]')
else
  CODEXCLI_CONTENT_JSON=$(jq -n --arg text "$CODEXCLI_TEXT" '[{type:"input_text", text:$text}]')
fi

declare -a CODEXCLI_MESSAGES
if [ -f "$CODEXCLI_HISTORY_FILE" ]; then
  CODEXCLI_MESSAGES=()
  while IFS= read -r obj; do
    CODEXCLI_MESSAGES+=("$obj")
  done < <(jq -c -s '.[]' "$CODEXCLI_HISTORY_FILE" 2>/dev/null || true)
else
  CODEXCLI_MESSAGES=()
fi

CODEXCLI_USER_MSG=$(jq -n --argjson content "$CODEXCLI_CONTENT_JSON" '{type:"message",role:"user",content:$content}')
CODEXCLI_MESSAGES+=("$CODEXCLI_USER_MSG")
CODEXCLI_INPUT_JSON=$(printf '%s\n' "${CODEXCLI_MESSAGES[@]}" | jq -s '.')

CODEXCLI_DATA=$(jq -n --arg model "$CODEXCLI_MODEL" \
--arg instructions "$CODEXCLI_INSTRUCTIONS" \
--arg input "$CODEXCLI_INPUT_JSON" \
'{
    model: $model,
    instructions: $instructions,
    input: ($input | fromjson),
    tools: [],
    tool_choice: "auto",
    parallel_tool_calls: false,
    reasoning: { effort: "minimal", summary: "auto" },
    store: false,
    stream: true,
    include: ["reasoning.encrypted_content"]
}')

CODEXCLI_TEMP_RESPONSE_FILE=$(mktemp)

# Executar curl e capturar saída completa (incluindo erros)
curl_output=$(curl -sS -N https://chatgpt.com/backend-api/codex/responses \
-X POST \
-H "Authorization: Bearer $CODEXCLI_ACCESS_TOKEN" \
-H "chatgpt-account-id: $CODEXCLI_ACCOUNT_ID" \
-H "OpenAI-Beta: responses=experimental" \
-H "Content-Type: application/json" \
-H "Accept: text/event-stream" \
-H "originator: codex_cli_rs" \
-H "User-Agent: codex_cli_rs" \
-H "session_id: $CODEXCLI_SESSION_ID" \
-d "$CODEXCLI_DATA" 2>&1)

# Verificar se há erro na resposta (JSON com campo "error")
if echo "$curl_output" | jq -e '.error' >/dev/null 2>&1; then
  error_msg=$(echo "$curl_output" | jq -r '.error.message // "Erro desconhecido no endpoint"')
  echo "Erro do endpoint: $error_msg" >&2
  rm -f "$CODEXCLI_TEMP_RESPONSE_FILE"
  exit 1
fi

# Processar streaming se não houver erro
echo "$curl_output" | awk '/^event: response.output_text.delta$/ { want=1; next } \
       /^event: response\.output_text\.done$/  { print "{\"__eol__\":true}"; fflush(); next } \
       want && /^data: / { sub(/^data: /,""); print; fflush(); want=0; next }' \
| jq -r --unbuffered 'if .delta? then .delta elif .eol? then "EOL" else empty end' \
| awk '{ if ($0=="EOL") { print ""; fflush(); } else { printf "%s", $0; fflush(); } }' \
| tee "$CODEXCLI_TEMP_RESPONSE_FILE"

CODEXCLI_ASSISTANT_TEXT=$(cat "$CODEXCLI_TEMP_RESPONSE_FILE")
rm -f "$CODEXCLI_TEMP_RESPONSE_FILE"

if [ -z "$CODEXCLI_ASSISTANT_TEXT" ]; then
  echo "Nenhuma resposta recebida do LLM." >&2
  exit 1
fi

CODEXCLI_ASSISTANT_MSG=$(jq -n --arg text "$CODEXCLI_ASSISTANT_TEXT" '{type:"message",role:"assistant",content:[{type:"output_text",text:$text}]}')
CODEXCLI_MESSAGES+=("$CODEXCLI_ASSISTANT_MSG")
printf '%s\n' "${CODEXCLI_MESSAGES[@]}" > "$CODEXCLI_HISTORY_FILE"
